######################################
##
## run-stressng
##
##    run stressng workload
##
######################################
apiVersion: tekton.dev/v1
kind: Task
metadata:
  name: run-stressng
spec:
  params:
  - name: arguments
    description: Define array of argument for CPU frequency and stressng workload (CPU_FREQUENCY;STRESS_LOAD;STRESS_INSTANCE_NUM;STRESS_EXTRA_PARAM_KEYS;STRESS_EXTRA_PARAM_VALS)
    type: array
  - name: TIMEOUT
    description: Timeout to sleep 
    default: 30
  - name: INTERVAL
    description: Interval between each run
    default: 10
  results:
  - name: stress-end-time
    description: The time recorded after running the workload
  volumes:
  - name: system-cpu
    hostPath:
      path: /sys/devices/system/cpu/cpufreq
      type: Directory
  steps:
    - name: run-stressng
      image: quay.io/sustainability/stress-ng:0.16.02
      volumeMounts:
      - mountPath: /sys/devices/system/cpu/cpufreq
        name: system-cpu
        readOnly: false
      args: ["$(params.arguments[*])"]
      securityContext:
        privileged: true
      script: |
            #!/usr/bin/env bash
            IFS=' '
            for argument in "$@"; do
                echo $argument
                IFS=";"
                read -a arguments <<< "$argument"
                CPU_FREQUENCY=${arguments[0]}
                STRESS_LOAD=${arguments[1]}
                STRESS_INSTANCE_NUM=${arguments[2]}
                STRESS_EXTRA_PARAM_KEYS=${arguments[3]}
                STRESS_EXTRA_PARAM_VALS=${arguments[4]}

                IFS=' '

                if [[ "$STRESS_LOAD" == "sleep" ]] ; then
                    echo "SLEEP $(params.TIMEOUT)"
                    sleep $(params.TIMEOUT)
                    exit 0
                fi

                # Different processes can be executed, so that to do CPU pinning properly we store the cpu index to be use in a file
                # If the files does not exist, we populate the file with the CPU index
                lscpu | grep "NUMA node"| tail -n +2  | while read -r line; do
                  cpus=$(echo $line | awk '{print $4}' | sed 's/,.*//g' | sed 's/-/ /g')
                  for i in $(seq $cpus); do
                    echo $i >> cpu-idx
                  done
                done
                lscpu | grep "NUMA node"| tail -n +2  | while read -r line; do
                  cpus=$(echo $line | awk '{print $4}' | sed 's/.*,//g' | sed 's/-/ /g') # the difference here is regex of the ","
                  for i in $(seq $cpus); do
                    echo $i >> cpu-idx
                  done
                done

                # Store the CPU max freq to revert it back if changed
                if [[ "$CPU_FREQUENCY" != "none" ]] ; then
                    mount -o remount,rw  /sys/devices/system/cpu/cpufreq
                    cat "/sys/devices/system/cpu/cpufreq/policy0/scaling_max_freq" > max_freq
                fi

                
                IFS=$'\n'
                for i in $(seq 1 $STRESS_INSTANCE_NUM); do
                  CPU=$(cat cpu-idx | tail -n 1)
                  cat cpu-idx | head -n -1  > tmp-cpu && rm -f cpu-idx && mv tmp-cpu cpu-idx
                  if [[ "$CPU_FREQUENCY" != "none" ]] ; then
                    echo "set CPU frequency"
                    echo $CPU_FREQUENCY | tee /sys/devices/system/cpu/cpufreq/policy${CPU}/scaling_max_freq
                  fi
                  if [[ "$STRESS_EXTRA_PARAM_KEYS" != "none" ]] ; then
                    echo /usr/bin/stress-ng --$STRESS_LOAD 1 --taskset ${CPU} --$STRESS_EXTRA_PARAM_KEYS "$STRESS_EXTRA_PARAM_VALS" --timeout $(params.TIMEOUT) --aggressive --metrics-brief
                    /usr/bin/stress-ng --$STRESS_LOAD 1 --taskset ${CPU} --$STRESS_EXTRA_PARAM_KEYS "$STRESS_EXTRA_PARAM_VALS" --timeout $(params.TIMEOUT) --aggressive --metrics-brief &        
                  else
                    echo /usr/bin/stress-ng --$STRESS_LOAD 1 --taskset ${CPU} --timeout $(params.TIMEOUT) --aggressive --metrics-brief
                    /usr/bin/stress-ng --$STRESS_LOAD 1 --taskset ${CPU} --timeout $(params.TIMEOUT) --aggressive --metrics-brief &    
                  fi
                done
                
                wait

                # Revert the CPU freq back to max
                if [[ "$CPU_FREQUENCY" != "none" ]] ; then
                  FREQ=$(cat max_freq)
                  echo $FREQ | tee /sys/devices/system/cpu/cpufreq/policy${CPU}/scaling_max_freq
                fi
                echo "finished"
                sleep $(params.INTERVAL)
            done
    - name: record-end-time
      image: bash:5.2
      script: |
          #!/usr/bin/env bash
          echo -n $(date +%Y-%m-%dT%H:%M:%SZ) > $(results.stress-end-time.path)